

[toc]

## Entry Points

在 webpack 配置中， 有多种方式去定义 `entry` 属性。 



### **单入口（简写）语法 （# Single Entry (Shorthand) Syntax）**

Usage: `entry: string | [string]`

**webpack.config.js**

```javascript
module.exports = {
    entry: './path/to/my/entry/file.js',
}
```

这是以下配置的 shorthand(#简写) ：

**webpack.config.js**

```javascript
module.exports = {
    entry: {
        main: './path/to/my/entry/file.js',
    },
}
```

我们也可以传入一个文件路径的数组， 用于指定多个入口文件。 

当你想要把多个依赖文件注入到一起，并构建他们的依赖图到一个 “chunk” 的时候，会很有用。 

**webpack.config.js**

```javascript
module.export = {
    entry: ['./src/file_1.js','./src/file_2.js'],
    output: {
        filename: 'bundle.js',
    }
}
```

单入口语法方便快捷，但是在扩展配置的时候，不够灵活。 



### **对象语法 (# Object Syntax)**

Usage : `entry: { <entryChunkName> string | [string] } | {}`

**webpack.config.js**

```javascript
module.exports = {
    entry: {
        app: './src/index.js',// 将会导出名为 app.js 的文件
        adminApp: './src/adminApp.js', // 将会导出名为 adminApp.js 的文件
    }
}
```

对象语法更加的冗长，但是它是定义 entry/entries 扩展性最强的一种写法。

> Tip
>
> **"Scalable webpack configurations"** are ones that can be reused and combined with other partial configurations. This is a popular technique used to separate concerns by environment, build target, and runtime. They are then merged using specialized tools like [webpack-merge](https://github.com/survivejs/webpack-merge).

>Tip
>
>You can pass empty object `{}` to `entry` when you have only entry points generated by plugins.





### **入口描述对象（#EntryDescription object）**

一个用于描述入口文件的对象， 你可以指定以下属性：

- `dependOn`: 当前入口 (#entry point )所依赖的其他入口(entry points)。 他们必须在当前入口加载之前加载。 
- `filename`: 指定要输出的文件名称
- `import` : 启动时需加载的模块
- `library` : 指定 `library` 选项，为当前entry 构建一个 `library` 
- `runtime` ： 运行时 chunk 的名字。 如果设置了， 就会创建一个新的运行时 chunk 。 在 webpack 5.43.0 之后，可以将其设定为 `false` 以避免一个新的运行时 chunk
- `publicPath` ： 当该入口的输出文件在浏览器中被引用时，为他们指定一个公共 URL 地址。 请查看 [output.publicPath](https://webpack.docschina.org/configuration/output/#outputpublicpath)。

**webpack.config.js**

```javascript
module.exports = {
    entry: {
        a2: 'dependingfile.js',
        b2: {
            dependOn: 'a2',
            import: './src/app.js'
        }
    }
}
```

`runtime` 和 `dependOn` **不应在同一个入口上同时使用**，所以如下配置无效，并且会抛出错误：

> @jayce:
>
> 这里的意思时，配置多入口，且入口文件之间有依赖关系。 上例中，即 别名文件 “./src/app.js” 为 “b2”, 并且该文件依赖于 “dependingfile.js”, (别名为 “a2”)
>
> 这时候针对多入口的配置，output 可以这样去指定：
> ```javascript
> output: {
>  path: path.resolve(__dirname, "dist"),
>  filename: "output_[name].js",
> },
> ```
>
> 将会打包出 ： output_app.js , output_utils.js 
>
> 如果你要将多个入口文件，打包成一个文件：
> ```javascript
> const path = require('path');
> 
> module.exports = {
>  entry: './path/to/my/entry/file.js',
>  output: {
>      path: path.resolve(__dirname, 'dist'),
>      filename: 'my-first-webpack.bundle.js',
>  },
> }
> ```
>
> ==像上面这种 有dependOn 的entry point 怎么打包为单个bundle?, 以及这里的dependOn 具体是什么意思，怎么用的？==









**webpack.config.js**

```javascript
module.exports = {
    entry: {
        a2: './a',
        b2: {
            runtime: 'x2',
            dependOn: 'a2',
            import: './b'
        }
    }
}
```

确保 `runtime` **不能指向已存在的入口名称**， 例如下面配置会抛出一个错误：
```javascript
module.exports = {
    entry: {
        a1: './a',
        b1: {
            runtime: 'a1',
            import: './b',
        }
    }
}
```

另外 `dependOn` 不能是循环引用的， 下面的例子也会抛出错误：

```javascript
module.exports = {
    entry: {
        a3: {
            import: './a,
            dependOn: 'b3',
        },
        b3: {
            import : './b',
            dependOn: 'a3'
        }
    }
}
```

> 多入口时，output 如何配置，请查看 [output](https://webpack.js.org/concepts/output/#multiple-entry-points) 章节



## 常见场景

以下列出一些入口配置和它们的实际用例：

### 分离 app 和 vendor （第三方库） 入口

**webpack.config.js**

```javascript
module.exports = {
    entry: {
        main: './src/app.js',
        vendor: './src/vendor.js'
    }
}
```

**webpack.prod.js**

```javascript
module.exports = {
    output:{
        filename:'[name].[contenthash].bundle.js'
    }
}
```

**webpack.dev.js**

```javascript
module.exports = {
    output: {
        filename: '[name].bundle.js'
    }
}
```

**这是什么？** 这是告诉 webpack 我们想要配置 2 个单独的入口点 （例如上面的示例）。

**为什么？** 这样你就可以在 `vendor.js` 中存入未做修改的必要 library 或者 文件 （例如 Bootstrap, jQuery, 图片等），然后将它们打包在一起成为单独的 chunk。内容哈希保持不变，这使浏览器可以独立地缓存他们，从而减少加载时间。

> @jayce: ==是在说，配置多个entry point, 这样可以隔离开vendors,从而浏览器会缓存这些不变的vendors，从而达到减少加载时间的目的吗？ 可是，==

> Tips
>
> 在 webpack < 4 的版本中，通常将 vendor 作为一个单独的入口起点添加到 entry 选项中，以将其编译为一个单独的文件 (与 CommonsChunkPlugin 结合使用)。
> 而在 webpack 4 中，不鼓励这么做。 而是使用 `optimization.splitChunk` 选项， 将 vendor 和 app 模块分开，并为其创建一个单独的文件。 不要为 vendor 或其他不是执行起点 创建 entry。



### 多页面应用程序

**webpack.config.js**

```javascript
module.exports = {
    entry : {
        pageOne: './src/pageOne/index.js',
        pageTwo: './src/pageTwo/index.js',
        pageThree: './src/pageThree/index.js',
    }
}
```

**这是什么？** 我们告诉 webpack  需要三个独立分离的 依赖图。

**为什么？** 在多页面应用程序中， server 会拉取一个新的 HTML 文档给你的客户端，页面重新加载此新的文档，并且资源被重新下载。 然而，这给我们特殊的机会去做很多事。例如使用 `optimization.splitChunks` 为页面间共享的应用程序代码创建 bundle。 由于入口起点数量的增加，多页应用能够复用多个入口起点之间的大量代码 / 模块， 从而可以极大地从这些技术中受益。

> Tips
>
> 根据经验： 每个HTML文档只使用一个入口起点。 具体原因请参阅[此 issue](https://bundlers.tooling.report/code-splitting/multi-entry/#webpack)。
> ==@jayce附件目录中有该连接文章的翻译，但是还是没明白啥意思，不知道和这里说的有什么联系。==
